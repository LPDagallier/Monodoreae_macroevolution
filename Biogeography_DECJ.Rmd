---
title: "Biogeography with DEC models"
author: "Léo-Paul Dagallier"
date:  "Last update: `r format(Sys.time(), '%d %B, %Y')`"
output: github_document
---

Author: Léo-Paul Dagallier

Last update: `r format(Sys.time(), '%d %B, %Y')`

```{r setup, include=FALSE, eval = T}
knitr::opts_chunk$set(echo = TRUE,
                        collapse  = TRUE,
                      fig.path  = "BiogeoDEC_files/figures/")
knitr::opts_chunk$set(eval = FALSE)
```

# BioGeoBEARS package
  http://phylo.wikidot.com/biogeobears#script
```{r install-package, eval = F}
install.packages("rexpokit")
install.packages("cladoRcpp")
library(devtools)
devtools::install_github(repo="nmatzke/BioGeoBEARS")
```

## Input data
### Monodoreae 3 dataset

Prepare the output folder:

```{bash, eval = F}
path_to_output="/home/dagallie/Documents/RESEARCH/DATA_ANALYSES/Diversification_analysis/outputs/Monodoreae_3";
cd $path_to_output
mkdir Biogeo_DEC
```


#### Monodoreae populations
Monodoreae MCC tree pruned with 1 specimen per population: accounting for the populations, e.g. Dennettia occurs both in West and Central Africa, so 1 specimen from West Africa and 1 from Central Africa in the tree.

Prepare the path variables: - in R:
```{r, eval = T}
path_to_tree = c("outputs/Monodoreae_3/name_MCC_monodoreae3_monod_pruned_biogeo.newick")
path_to_output = c("outputs/Monodoreae_3/Biogeo_DEC/")
data_suffix <- "Monodoreae_3_pop"
data_prefix <- "Monodoreae_3_pop"
wd = "/home/dagallie/Documents/RESEARCH/DATA_ANALYSES/Diversification_analysis/"
path_to_treefile <- paste0(wd, path_to_tree)
path_to_geotf <- "/home/dagallie/Documents/RESEARCH/DATA_ANALYSES/Diversification_analysis/data/monodoreae_3_pop_DEC_ranges.txt"
data_text = "Monodoreae 3 (pop)"
```

#### Monodoreae simple
Monodoreae MCC tree pruned with 1 specimen per species: no account for the populations, but accounting for the range of each species, e.g. Dennettia occurs both in West and Central Africa, so 1 specimen representing the species in the tree but occurring in both regions.

Prepare the path variables: - in R:
```{r, eval = T}
path_to_tree = c("outputs/Monodoreae_3/name_MCC_monodoreae3_monod_pruned.newick")
path_to_tree_beast = c("outputs/Monodoreae_3/name_MCC_monodoreae3_monod_pruned.tree")
path_to_output = c("outputs/Monodoreae_3/Biogeo_DEC/")
data_suffix <- "Monodoreae_3"
data_prefix <- "Monodoreae_3"
wd = "/home/dagallie/Documents/RESEARCH/DATA_ANALYSES/Diversification_analysis/"
path_to_treefile <- paste0(wd, path_to_tree)
path_to_treefile_beast <- paste0(wd, path_to_tree_beast)
path_to_geotf <- "/home/dagallie/Documents/RESEARCH/DATA_ANALYSES/Diversification_analysis/data/monodoreae_3_DEC_ranges.txt"
data_text = "Monodoreae 3"
path_to_disp_multip_fn <- "/home/dagallie/Documents/RESEARCH/DATA_ANALYSES/Diversification_analysis/outputs/Monodoreae_3/Biogeo_DEC/dispersal_multipliers"
path_to_areas_adj_fn <- "/home/dagallie/Documents/RESEARCH/DATA_ANALYSES/Diversification_analysis/outputs/Monodoreae_3/Biogeo_DEC/areas_adjacency"
```

## Read the tree
```{r, eval = T, message=F}
library(ape)
library(picante)
library(treeio)
tree <-  read.tree(file = path_to_treefile)
tree_beast <-  read.beast(file = path_to_treefile_beast)
tot_time <- max(node.age(tree)$ages)
```

## Packages load

```{r, warning=FALSE, eval=TRUE, echo=FALSE, message=F}
library(rexpokit)
library(cladoRcpp)
library(BioGeoBEARS)
library(parallel)
setwd(dir = paste0(wd, path_to_output))
```

Prepare a file with the ranges of each species.
```{r}
# Look at the raw geography text file:
moref(path_to_geotf)
# Look at your geographic range data:
tipranges = getranges_from_LagrangePHYLIP(lgdata_fn=path_to_geotf)
tipranges
# Maximum range size observed:
max(rowSums(dfnums_to_numeric(tipranges@df)))
# Set the maximum number of areas any species may occupy; this cannot be larger 
# than the number of areas you set up, but it can be smaller.
max_range_size = 3
```

Modify the list of possible ranges:
```{r}
# Get your states list (assuming, say, 4-area analysis, with max. rangesize=4)
max_range_size = 3
areas = getareas_from_tipranges_object(tipranges)
#areas = c("A", "B", "C", "D")

# This is the list of states/ranges, where each state/range
# is a list of areas, counting from 0
states_list_0based = rcpp_areas_list_to_states_list(areas=areas, maxareas=max_range_size, include_null_range=TRUE)

# How many states/ranges, by default: 163
length(states_list_0based)

# Make the list of ranges
ranges_list = NULL
for (i in 1:length(states_list_0based))
    {    
    if ( (length(states_list_0based[[i]]) == 1) && (is.na(states_list_0based[[i]])) )
        {
        tmprange = "_"
        } else {
        tmprange = paste(areas[states_list_0based[[i]]+1], collapse="")
        }
    ranges_list = c(ranges_list, tmprange)
    }

# Look at the ranges list
ranges_list

# How many states/ranges, by default: 163
length(ranges_list)

# Let's remove some non-adjacent ranges
nonadjacent=c("WE","WM","CM","WEM","CEM", "WCM")
keepTF = ranges_list %in% nonadjacent == FALSE

ranges_list_NEW = ranges_list[keepTF]
length(ranges_list_NEW)     # now 148

states_list_0based_NEW = states_list_0based[keepTF]
length(states_list_0based_NEW)     # now 148
```


# DEC and DEC+J analysis

Run DEC analysis.
```{r, echo=FALSE, message=FALSE, results='hide'}
# Intitialize a default model (DEC model)
BioGeoBEARS_run_object = define_BioGeoBEARS_run()
# Give BioGeoBEARS the location of the phylogeny Newick file
BioGeoBEARS_run_object$trfn = path_to_treefile
# Give BioGeoBEARS the location of the geography text file
BioGeoBEARS_run_object$geogfn = path_to_geotf

# Give BioGeoBEARS the location of the dispersal multiplier text file
BioGeoBEARS_run_object$dispersal_multipliers_fn = path_to_disp_multip_fn
# Give BioGeoBEARS the location of the area adjacency text file
BioGeoBEARS_run_object$areas_adjacency_fn = path_to_areas_adj_fn

# Input the maximum range size
BioGeoBEARS_run_object$max_range_size = max_range_size
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.

# INPUT the NEW states list into the BioGeoBEARS_run_object
BioGeoBEARS_run_object$states_list = states_list_0based_NEW

# Speed options and multicore processing if desired
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()
BioGeoBEARS_run_object$num_cores_to_use = 1

BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale

# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!
# (It also runs some checks on these inputs for certain errors.)
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)

# Good default settings to get ancestral states
BioGeoBEARS_run_object$return_condlikes_table = TRUE
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run

# Add j as a FIXED parameter with low value
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "fixed"
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = 0.0001
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = 0.0001

# Add a (range switching) as a FIXED parameter with a 1 value = "v3 analysis"
ainit = 0.01
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["a","type"] = "free"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["a","init"] = ainit
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["a","est"] = ainit

# vinit = 1
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "free"
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","init"] = vinit
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","est"] = vinit
# 
# sinit = 1
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "free"
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = sinit
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = sinit

# This table contains the parameters of the model 
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table

# Run this to check inputs. Read the error messages if you get them!
check_BioGeoBEARS_run(BioGeoBEARS_run_object)

# set the working directory for BioGeoBEARS
BioGeoBEARS_run_object$wd = paste0("~/Documents/RESEARCH/DATA_ANALYSES/Diversification_analysis/outputs/", data_prefix, "/Biogeo_DEC/")

# For a slow analysis, run once, then set runslow=FALSE to just 
# load the saved result.
runslow = F

# Set the name of the output file
resfn = paste0(data_prefix, "_DEC_M0_unconstrained_final.Rdata")

# run DEC
if (runslow)
{
  res = bears_optim_run(BioGeoBEARS_run_object)
  res    
  
  save(res, file=resfn)
  resDEC = res
} else {
  # Loads to "res"
  load(resfn)
  resDEC = res
}
```

Export the result table to .csv file:
```{r}
write.csv(resDEC[["outputs"]]@params_table, file = paste0("DEC_parameters_results_final_", data_suffix, ".csv"))
```


Run DEC+J analysis
```{r}
BioGeoBEARS_run_object = define_BioGeoBEARS_run()
BioGeoBEARS_run_object$trfn = path_to_treefile
BioGeoBEARS_run_object$geogfn = path_to_geotf
BioGeoBEARS_run_object$max_range_size = max_range_size
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.
# (For DEC* and other "*" models, please cite: Massana, Kathryn A.; Beaulieu, 
#  Jeremy M.; Matzke, Nicholas J.; O’Meara, Brian C. (2015). Non-null Effects of 
#  the Null Range in Biogeographic Models: Exploring Parameter Estimation in the 
#  DEC Model. bioRxiv,  http://biorxiv.org/content/early/2015/09/16/026914 )
# Also: search script on "include_null_range" for other places to change

# INPUT the NEW states list into the BioGeoBEARS_run_object
BioGeoBEARS_run_object$states_list = states_list_0based_NEW

# Speed options and multicore processing if desired
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()
BioGeoBEARS_run_object$num_cores_to_use = 1
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale

# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!
# (It also runs some checks on these inputs for certain errors.)
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)

# Good default settings to get ancestral states
BioGeoBEARS_run_object$return_condlikes_table = TRUE
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run

# Set up DEC+J model
# Get the ML parameter values from the 2-parameter nested model
# (this will ensure that the 3-parameter model always does at least as good)
dstart = resDEC$outputs@params_table["d","est"]
estart = resDEC$outputs@params_table["e","est"]
jstart = 0.0001

# Input starting values for d, e
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart

# Add j as a free parameter
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart

check_BioGeoBEARS_run(BioGeoBEARS_run_object)

resfn = paste0(data_suffix, "_DEC+J_M0_unconstrained_v1.Rdata")
runslow = F

if (runslow)
{
  res = bears_optim_run(BioGeoBEARS_run_object)
  res    
  
  save(res, file=resfn)
  resDECj = res
} else {
  # Loads to "res"
  load(resfn)
  resDECj = res
}
```

## Plot ancestral states - DEC
```{r}
analysis_titletxt = paste0("BioGeoBEARS DEC on ", data_text, " M0_unconstrained")

# Setup
results_object = resDEC
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))

# States
# res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=F, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tree, tipranges=tipranges)

# Pie chart
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=F, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tree, tipranges=tipranges)
```

## Plot ancestral states - DEC+J
```{r}
analysis_titletxt = paste0("BioGeoBEARS DEC+J on ", data_text, " M0_unconstrained")

# Setup
results_object = resDECj
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))

# States
# res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tree, tipranges=tipranges)

# Pie chart
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=F, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tree, tipranges=tipranges)
```

## plot with ggtree
```{r}
states_prob = data.frame(resDEC[["ML_marginal_prob_each_state_at_branch_top_AT_node"]])
colnames(states_prob) <- ranges_list_NEW
# In this table:
# - columns are states/ranges
# - rows are nodes, in APE order (tips, then root, then internal)

#  You can see the node numbers in the same APE order with:
trtable = prt(tree, printflag=FALSE)
head(trtable)
tail(trtable)

states_prob$node <-  trtable$node

library(ggtree)
library(tidytree)
library(ggplot2)
library(colorspace)

tree_data <-  full_join(tree, states_prob)

# colors = c("W" = "#d22f2f", "C" = "#1f78b4", "E" = "#33a02c", "M" = "#fdbf6f", "WC" = "#6a3d9a", "CE" = "#298C70", "EM" = "#98af4e", "WCE" = "#7D3800")
# colors = c("W" = "#984ea3", "C" = "#377eb8", "E" = "#4daf4a", "M" = "#ff7f00", "WC" = "#6866ae", "CE" = "#429681", "EM" = "#a69725", "WCE" = "#5e7e8c") # Color mixing Set1
# colors = c("W" = "#984ea3", "C" = "#009fff", "E" = "#4daf4a", "M" = "#f77525", "WC" = "#4c77d1", "CE" = "#26a7a5", "EM" = "#a29238", "WCE" = "#4c89a4") # Color mixing set perso 2
# colors = c("W" = "#b23ec6", "C" = "#009fff", "E" = "#45c042", "M" = "#f77525", "WC" = "#596fe3", "CE" = "#22b0a1", "EM" = "#9e9a34", "WCE" = "#9c692d") # Color mixing set perso 3
# colors = c("W" = "#b23ec6", "C" = "#009fff", "E" = "#45c042", "M" = "#f77525", "WC" = "#596fe3", "CE" = "#29d0be", "EM" = "#d6d034", "WCE" = "#9c692d") # Color mixing set perso 4 gradient

# colors = c("W" = "#e41a1c", "C" = "#377eb8", "E" = "#4daf4a", "M" = "#ffff33", "WC" = "#984ea3", "CE" = "#24beb1", "EM" = "#ff7f00", "WCE" = "#a65628") # Color mixing set perso 5
colors = c("W" = "#e41a1c", "C" = "#008cff", "E" = "#1da819", "M" = "#ffff33", "WC" = "#984ea3", "CE" = "#14c9a9", "EM" = "#ff7f00", "WCE" = "#a65628") # Color mixing set perso 6 (= clearer set5)
demoplot(colors, "pie")

  pies=nodepie(states_prob, cols = 2:9, outline.color = "black",outline.size = 0.2)
pies <- lapply(pies, function(g) g+scale_fill_manual(values = colors))

legend_df = data.frame(name = names(x = colors), position_x = rep(x = 1,8),  position_y = 1:8, color = colors, label = c("West", "Centre", "East", "Madagascar", "West-Centre", "Centre-East", "East-Madagascar", "West-Centre-East"))

library(phytools)
max = max(nodeHeights(tree_data@phylo))

# (ggtree(tree_data)  +
#     geom_tiplab(offset = 0.2, size = 2.5)+
#       
#       # geom_point2(aes(x = x+1, subset=isTip, color= C), shape = 15, size = 2)+
#     geom_point2(aes(x = x, y = y), size = 3.9, color = "black") +
#       geom_inset(pies, width = 0.038, hjust = max+0.05,  vjust = 0.15, reverse_x = F, x = "node")  +
#     scale_color_manual(values = colors) +
#     theme_tree2() +
#     theme(axis.line.x.bottom = element_line("#bdbdbd"),
#           panel.grid.major.x = element_line("#bdbdbd"),
#           panel.grid.minor.x = element_line("#f0f0f0"),
#           legend.position=c(0.1, 0.8))) %>% revts()+ scale_x_continuous(labels=abs, breaks = c(0,-10,-20,-30), limits = c(-30, 10))
# ggsave(filename = paste0(data_prefix,"_DEC4",".pdf"), width = 40, height = 30, units = "cm")
# 
# (ggtree(tree_data)  +
#     geom_tiplab(offset = 0.2, size = 3)+
#     geom_point(data = legend_df, aes(x = position_x-25, y = position_y+75, color = name))+
#     scale_color_manual(values = legend_df$color, name = "", labels = legend_df$label) +
#     geom_point2(aes(x = x, y = y), size = 5, color = "black") +
#     geom_inset(pies, width = 0.05, hjust = max+0.06,  vjust = 0.11, reverse_x = F, x = "node")  +
#     theme_tree2() +
#     theme(axis.line.x.bottom = element_line("#bdbdbd"),
#           panel.grid.major.x = element_line("#bdbdbd"),
#           panel.grid.minor.x = element_line("#f0f0f0"),
#           legend.position=c(0.1, 0.9),
#           legend.text=element_text(size=15))) %>% revts()+ scale_x_continuous(labels=abs, breaks = c(0,-10,-20,-30), limits = c(-27, 9))+ guides(color = (guide_legend(override.aes = list(size=5))))
# ggsave(filename = paste0(data_prefix,"_DEC5",".pdf"), width = 30, height = 40, units = "cm")

(ggtree(tree_data)  +
    # geom_tiplab(offset = 0.5, size = 4)+
    geom_point(data = legend_df, aes(x = position_x-25, y = position_y+75, color = name))+
    scale_color_manual(values = legend_df$color, name = "Geographical range", labels = legend_df$label) +
    # geom_point2(aes(x = x, y = y), size = 7.9, color = "black") +
    geom_inset(pies, width = 0.05, hjust = max+0.065,  vjust = 0.10, reverse_x = F, x = "node")  +
    # geom_nodelab(aes(x=x, label=node), hjust=-1, size=2, color = "black") +
    # geom_text(aes(x=x, label=node), hjust=-1, size=2, color = "black") +
    geom_tiplab(offset = 1, size = 4)+
    theme_tree2() +
    theme(axis.line.x.bottom = element_line("#bdbdbd"),
          panel.grid.major.x = element_line("#bdbdbd"),
          panel.grid.minor.x = element_line("#f0f0f0"),
          legend.position=c(0.2, 0.92),
          legend.text=element_text(size=15))) %>% revts()+ scale_x_continuous(labels=abs, breaks = c(0,-10,-20,-30), limits = c(-27, 12))+ guides(color = (guide_legend(override.aes = list(size=8))))
ggsave(filename = paste0(data_prefix,"_DEC3_test",".pdf"), width = 30, height = 50, units = "cm")
```

### With geological timescale
```{r}
library(deeptime)
GTS <- force(epochs)
lmio <-  c("Late Miocene", 11.6300, 5.3330, "L.Mio", "#FFFF66")
mmio <-  c("Middle Miocene", 15.9700, 11.6300, "M.Mio", "#FFFF4D")
emio <-  c("Early Miocene", 23.0300, 15.9700, "E.Mio", "#FFFF33")
GTS_perso <- rbind(GTS[c(1:3),], lmio, mmio, emio, GTS[5,])
GTS_perso$max_age <- as.numeric(GTS_perso$max_age)
GTS_perso$min_age <- as.numeric(GTS_perso$min_age)
```


```{r}
library(ggpp)
gg =(ggtree(tree_data) +
    geom_point(data = legend_df, aes(x = position_x-25, y = position_y+75, color = name))+
    scale_color_manual(values = legend_df$color, name = "Geographical range", labels = legend_df$label) +
    # geom_inset(pies[120], width = 0.05, hjust = max+0.065,  vjust = 0.10, reverse_x = F, x = "node")  +
    geom_tiplab(offset = 0.5, size = 4)+
   
    theme_tree2() +
    theme(axis.line.x.bottom = element_line("#bdbdbd"),
          panel.grid.major.x = element_line("#bdbdbd"),
          panel.grid.minor.x = element_line("#f0f0f0"),
          legend.position=c(0.2, 0.92),
          legend.text=element_text(size=15))) %>% revts()+ scale_x_continuous(labels=abs, breaks = c(0,-10,-20,-30), limits = c(-27, 12))+ guides(color = (guide_legend(override.aes = list(size=8))))
gg

# ggsave(filename = paste0(data_prefix,"_DEC3_test",".pdf"), width = 30, height = 50, units = "cm")
# gg =(ggtree(tree_data))
df <- tibble::tibble(node=as.numeric(states_prob$node), pies=pies)
gg2 = gg %<+% df
gg3 = gg2 + geom_plot(data = td_filter(node %in% 1:500), mapping=aes(x=x,y=y, label=pies), vp.width=0.027, hjust=0.58, vjust=0.502) + coord_geo(neg = T, pos = "b", dat = GTS_perso, abbrv = F, height = unit(1, "line"), size = 2.7, bord = c(), skip = c("Holocene"), expand = T, center_end_labels = T)

pdf(file = paste0(data_prefix,"_DEC3_GTS_ok_for_publi",".pdf"), width = 11.8 , height = 19.7)
gg3
dev.off()
```

```{r}
# LANDSCAPE FORMAT
library(deeptime)
p <- (ggtree(tree_data)  +
    # geom_tiplab(offset = 0.5, size = 4)+
    geom_point(data = legend_df, aes(x = position_x-25, y = position_y+75, color = name))+
    scale_color_manual(values = legend_df$color, name = "Geographical range", labels = legend_df$label) +
    geom_point2(aes(x = x, y = y), size = 7.9, color = "black") +
    geom_inset(pies, width = 0.04, hjust = max+0.04,  vjust = 0.15, reverse_x = F, x = "node")  +
    # geom_nodelab(aes(x=x, label=node), hjust=-1, size=2, color = "black") +
    # geom_text(aes(x=x, label=node), hjust=-1, size=2, color = "black") +
    geom_tiplab(offset = 1, size = 4)+
    theme_tree2() +
    # coord_geo(xlim = c(-27,12), ylim = c(-2,Ntip(tree)), neg = TRUE, abbrv = F, dat = list("epochs", "periods"), skip = c("Early Cretaceous", "Pliocene", "Pleistocene", "Holocene")) +
    theme(axis.line.x.bottom = element_line("#bdbdbd"),
          panel.grid.major.x = element_line("#bdbdbd"),
          panel.grid.minor.x = element_line("#f0f0f0"),
          axis.text.x = element_text(size = 30),
          legend.position=c(0.15, 0.87),
          legend.text=element_text(size=15))) %>% revts()+ scale_x_continuous(labels=abs, breaks = c(0,-10,-20,-30), limits = c(-27, 12))+ guides(color = (guide_legend(override.aes = list(size=8))))
p
ggsave(filename = paste0(data_prefix,"_DEC3_landscape_2",".pdf"), width = 70, height = 30, units = "cm")
# ggsave(filename = paste0(data_prefix,"_DEC3_landscape_empty",".pdf"), width = 50, height = 30, units = "cm")
# png(filename = paste0(data_prefix,"_DEC3_landscape_empty_GTS",".pdf"), width = 50, height = 30, units = "cm", res = 300)
# p
# dev.off()

```

Check the node numbers equivalency between newick tree and beast tree
```{r}
ggtree(tree_data)+
  geom_tiplab(offset = 0.5, size = 4)+
  geom_nodelab(aes(x=x, label=node), hjust=-1, size=2, color = "black")
ggtree(tree_beast)+
  geom_tiplab(offset = 0.5, size = 4)+
  geom_nodelab(aes(x=x, label=node), hjust=-1, size=2, color = "red")
```

Merge the data from tree_beast into tree_data
```{r}
tree_beast@data$node <- as.numeric(tree_beast@data$node)
tree_data_full <-  full_join(tree_data@data, tree_beast@data, by = "node")
```

## Extract the vicariance and sympatry splits events
Get the nodes number with vicariances.  

Don't use this:
```{r}
# vicariance 
tree_data_full$vicariance <- NA
centre_east <- c(119, 102, 97, 129, 174)
east_west <- c(147)
centre_west <- c(109, 162, 156)
for (n in centre_east){
  tree_data_full$vicariance[which(tree_data_full$node == n)] <- "centre_east"
}
for (n in east_west){
  tree_data_full$vicariance[which(tree_data_full$node == n)] <- "east_west"
}
for (n in centre_west){
  tree_data_full$vicariance[which(tree_data_full$node == n)] <- "centre_west"
}

# founder event
tree_data_full$founder_event <- NA
east_mada <- c(112)
for (n in east_mada ){
  tree_data_full$founder_event[which(tree_data_full$node == n)] <- "east_mada"
}

# sympatry (subset)
tree_data_full$sympatry_subset <- NA
widespread_east <- c(111, 105, 131, 125, 169, 146, 136)
CE_WCE_centre <- c(107, 106, 92, 130, 168, 139, 172, 125)
WC_centre <-  c(145)
widespread_west <- c(117, 154, 144, 173) # widespread = WC or WCE ?
for (n in widespread_east ){
  tree_data_full$sympatry_subset[which(tree_data_full$node == n)] <- "widespread_east"
}
for (n in CE_WCE_centre ){
  tree_data_full$sympatry_subset[which(tree_data_full$node == n)] <- "CE_WCE_centre"
}
for (n in WC_centre ){
  tree_data_full$sympatry_subset[which(tree_data_full$node == n)] <- "WC_centre"
}
for (n in widespread_west ){
  tree_data_full$sympatry_subset[which(tree_data_full$node == n)] <- "widespread_west"
}

# range expansion
tree_data_full$range_expansion <- NA
east_CE_WCE <- c(171, 138, 124, 91, 135)
centre_WC <- c(143, 161, 94, 93, 96, 108)
centre_CE <-  c(126)
west_WC <- c(170, 118)
for (n in east_CE_WCE ){
  tree_data_full$range_expansion[which(tree_data_full$node == n)] <- "east_CE_WCE"
}
for (n in centre_WC ){
  tree_data_full$range_expansion[which(tree_data_full$node == n)] <- "centre_WC"
}
for (n in centre_CE ){
  tree_data_full$range_expansion[which(tree_data_full$node == n)] <- "centre_CE"
}
for (n in west_WC ){
  tree_data_full$range_expansion[which(tree_data_full$node == n)] <- "west_WC"
}

```

Use this instead:
```{r}
tree_data_full$event <-  NA
tree_data_full$direction <- NA
# vicariance 
centre_east <- c(119, 102, 97, 129, 174)
east_west <- c(147)
centre_west <- c(109, 162, 156)
for (n in centre_east){
  tree_data_full$event[which(tree_data_full$node == n)] <- "vicariance"
  tree_data_full$direction[which(tree_data_full$node == n)] <- "centre_east"
}
for (n in east_west){
  tree_data_full$event[which(tree_data_full$node == n)] <- "vicariance"
  tree_data_full$direction[which(tree_data_full$node == n)] <- "east_west"
}
for (n in centre_west){
  tree_data_full$event[which(tree_data_full$node == n)] <- "vicariance"
  tree_data_full$direction[which(tree_data_full$node == n)] <- "centre_west"
}

# founder event
east_mada <- c(112)
for (n in east_mada ){
  tree_data_full$event[which(tree_data_full$node == n)] <- "founder_event"
  tree_data_full$direction[which(tree_data_full$node == n)] <- "east_mada"
}

# sympatry (subset)
widespread_east <- c(111, 105, 131, 125, 169, 146, 136)
CE_WCE_centre <- c(107, 106, 92, 130, 168, 139, 172, 125)
WC_centre <-  c(145)
widespread_west <- c(117, 154, 144, 173) # widespread = WC or WCE ?
for (n in widespread_east ){
    tree_data_full$event[which(tree_data_full$node == n)] <- "sympatry_subset"
  tree_data_full$direction[which(tree_data_full$node == n)] <- "widespread_east"
}
for (n in CE_WCE_centre ){
  tree_data_full$event[which(tree_data_full$node == n)] <- "sympatry_subset"
  tree_data_full$direction[which(tree_data_full$node == n)] <- "CE_WCE_centre"
}
for (n in WC_centre ){
  tree_data_full$event[which(tree_data_full$node == n)] <- "sympatry_subset"
  tree_data_full$direction[which(tree_data_full$node == n)] <- "WC_centre"
}
for (n in widespread_west ){
  tree_data_full$event[which(tree_data_full$node == n)] <- "sympatry_subset"
  tree_data_full$direction[which(tree_data_full$node == n)] <- "widespread_west"
}

# range expansion
east_CE_WCE <- c(171, 138, 124, 91, 135)
centre_WC <- c(143, 161, 94, 93, 96, 108)
centre_CE <-  c(126)
west_WC <- c(170, 118)
for (n in east_CE_WCE ){
  tree_data_full$event[which(tree_data_full$node == n)] <- "range_expansion"
  tree_data_full$direction[which(tree_data_full$node == n)] <- "east_CE_WCE"
}
for (n in centre_WC ){
    tree_data_full$event[which(tree_data_full$node == n)] <- "range_expansion"
  tree_data_full$direction[which(tree_data_full$node == n)] <- "centre_WC"
}
for (n in centre_CE ){
    tree_data_full$event[which(tree_data_full$node == n)] <- "range_expansion"
  tree_data_full$direction[which(tree_data_full$node == n)] <- "centre_CE"
}
for (n in west_WC ){
    tree_data_full$event[which(tree_data_full$node == n)] <- "range_expansion"
  tree_data_full$direction[which(tree_data_full$node == n)] <- "west_WC"
}

```

## Plot the vicariance and sympatry events
```{r}
library(dplyr)
library(ggrepel)

a = bind_cols(tree_data_full$height_0.95_HPD)
tree_data_full$height_0.95_HPD_lower <- as.numeric(a[1,])
tree_data_full$height_0.95_HPD_upper <- as.numeric(a[2,])


# ggplot(tree_data_full[which(!is.na(tree_data_full$event)),])+
# 
#   geom_segment(aes(x = height_0.95_HPD_lower, xend = height_0.95_HPD_upper, y = event, yend = event, color = direction), na.rm = T, position = position_nudge(y = seq(from = -0.2, to = 0.2, by = 0.02)))+
#   # geom_point(aes(x = height, y = event, color = direction), position = position_nudge(y = seq(from = -0.2, to = 0.2, by = 0.02)))+
#     # geom_segment(aes(x = height_0.95_HPD_lower, xend = height_0.95_HPD_upper, y = 10, yend = 10, color = vicariance), position = position_jitter(width = 0, height = 4))+
#   # geom_rect(aes(xmin = height_0.95_HPD_lower, xmax = height_0.95_HPD_upper, ymin = 11, ymax = 12, fill = sympatry_subset), alpha = 0.5)+
#   # scale_color_manual(na.value = "transparent")+
#   scale_x_reverse()+
#   theme_bw()

seq(from = -0.1, to = 0.1, by = 0.02)

# colors = c("W" = "#e41a1c", "C" = "#377eb8", "E" = "#4daf4a", "M" = "#ffff33", "WC" = "#984ea3", "CE" = "#35978f", "EM" = "#ff7f00", "WCE" = "#a65628") # Color mixing set perso 5
colors <- c("centre_east" = "#35978f", "east_west" = "#a65628", "centre_west" = "#984ea3", "east_mada" = "#ffff33", "widespread_east" = "#4daf4a", "CE_WCE_centre" = "#377eb8", "WC_centre" = "#377eb8", "widespread_west" = "#e41a1c", "east_CE_WCE" = "#4daf4a", "centre_WC" = "#377eb8", "centre_CE" = "#377eb8", "west_WC" = "#e41a1c")


colors = c("W" = "#e41a1c", "C" = "#008cff", "E" = "#1da819", "M" = "#ffff33", "WC" = "#984ea3", "CE" = "#14c9a9", "EM" = "#ff7f00", "WCE" = "#a65628") # Color mixing set perso 6 (= clearer set5)
demoplot(colors, "pie")
colors <- c("centre_east" = "#14c9a9", "east_west" = "#a65628", "centre_west" = "#984ea3", "east_mada" = "#ffff33", "widespread_east" = "#1da819", "CE_WCE_centre" = "#008cff", "WC_centre" = "#008cff", "widespread_west" = "#e41a1c", "east_CE_WCE" = "#1da819", "centre_WC" = "#008cff", "centre_CE" = "#008cff", "west_WC" = "#e41a1c")
demoplot(colors, "pie")

labels <- c("centre_east" = "Centre-East", "east_west" = "East-West", "centre_west" = "Centre-West", "east_mada" = "East to Madagascar", "widespread_east" = "Widespread to East", "CE_WCE_centre" = "Centre-East or West-Centre-East to Centre", "WC_centre" = "West-Centre to Centre", "widespread_west" = "Widespread to West", "east_CE_WCE" = "East to Widespread", "centre_WC" = "Centre to West-Centre", "centre_CE" = "Centre to Centre-East", "west_WC" = "West to West-Centre")

tree_data_full$event[which(tree_data_full$event =="vicariance")] <- "Vicariance"
tree_data_full$event[which(tree_data_full$event =="founder_event")] <- "Founder event"
tree_data_full$event[which(tree_data_full$event =="range_expansion")] <- "Range expansion (dispersion)"
tree_data_full$event[which(tree_data_full$event =="sympatry_subset")] <- "Range contraction (sympatry subset)"

labels_facet = c("vicariance" = "Vicariance", "founder_event" = "Founder event", "sympatry_subset" = "Range contraction (sympatry subset)", "range_expansion" = "Range expansion")
# seq = seq(from = 0, to = 1, by = 0.05)
# seq = c(0, 0.05, -0.05, 0.1, -0.1)
# seq = seq(from = -43/2, to = 43/2, by = 1)/43
# seq = rep(c(0, 0.15, -0.15), 22)
# seq = (1:43)/43
# seq = c(rep(0, 42), 0.3)
# seq = c(0)

# 
# seq = c(0, 0.4, 0.2, 0, -0.2, -0.4)
# 
# c(0, seq(from= max, to = min, by = 0.2))
# 
# seq(from = -0.2*8/2, length.out = 8, by = 0.2)
# seq(from = -by*length/2, length.out = length, by = by)
# by = 0.2
# length = 7
# round(seq(from = -(by*length/2)+by/2, length.out = length, by = by), 2)


data <- tree_data_full[which(!is.na(tree_data_full$event)),]
data <- arrange(data, event, desc(direction), (as.numeric(height)))
data$nudge_y <- NA
data$levels <-  paste0(data$event, "_", data$direction)
table_lev <-  table(data$levels)


for (lev in unique(data$levels)){
  by <-  0.15
  length <-  length(which(data$levels == lev))
  if (length < 8){
      data$nudge_y[which(data$levels == lev)] <-  round(seq(from = -(by*length/2)+by/2, length.out = length, by = by), 2)    
  } else {
     data$nudge_y[which(data$levels == lev)] <-  c(round(seq(from = -(by*(length-1)/2)+by/2, length.out = length-1, by = by), 2), 0)   
  }
}

ggplot(data)+
  geom_point(aes(x = as.numeric(height), y = direction, color = direction), size = 2.5, position = position_nudge(y = data$nudge_y))+
  geom_segment(aes(xend = height_0.95_HPD_lower, x = height_0.95_HPD_upper, y = direction, yend = direction, color = direction), size = 1.7, alpha = 1, position = position_nudge(y = data$nudge_y))+
  # geom_text(aes(x = as.numeric(height), y = direction, label = paste0(round(height_0.95_HPD_upper, 2)," - ", round(height_0.95_HPD_lower, 2))), size = 2, position = position_nudge(y = data$nudge_y+0.07))+
    # geom_text(aes(x = as.numeric(height), y = direction, label = paste0(round(height_0.95_HPD_upper, 2)," - ", round(height_0.95_HPD_lower, 2))), size = 1.5, position = position_nudge(y = data$nudge_y))+
    geom_text(aes(x = as.numeric(height_0.95_HPD_lower)-1, y = direction, label = paste0(round(height_0.95_HPD_upper, 2)," - ", round(height_0.95_HPD_lower, 2))), size = 2, position = position_nudge(y = data$nudge_y))+
  geom_text(aes(label = event), x = -27, y = Inf, hjust = "left", vjust = 1.7, check_overlap = T)+
  scale_fill_discrete(labels = labels_facet)+
  scale_color_manual(values = colors, labels = labels)+
  scale_y_discrete(labels = labels)+
scale_x_reverse(breaks = seq(from = 0, to = 30, by = 1))+
  facet_grid(rows = vars(event), scales = "free_y", space = "free_y", labeller = labeller(event = labels_facet))+
    theme_bw() +
  theme(legend.position = "none",
        panel.grid.major.y = element_blank(),
        strip.background = element_blank(),
        strip.text = element_blank())+
  labs(x = "My before present", y ="")
ggsave(filename = paste0("FIGURE_DEC_Splitting_events_Monodoreae_3.pdf"), units = "cm", width = 30, height = 20)

# ggplot(tree_data_full[which(!is.na(tree_data_full$event)),])+
#   geom_point(aes(y = as.numeric(height), x = direction, color = direction), size = 2, position = position_dodge(width = 0.9))+
#   geom_segment(aes(yend = height_0.95_HPD_lower, y = height_0.95_HPD_upper, x = direction, xend = direction, color = direction, group = height), size = 1, alpha = 0.8, position = position_dodge(width = 0.5, preserve = "total"))+
#   # geom_text(aes(x = as.numeric(height), y = direction, label = paste0(round(height_HPD_upper, 2)," - ", round(height_HPD_lower, 2))), size = 2, vjust = -1.5)+
#     # geom_text_repel(aes(x = as.numeric(height), y = direction, label = paste0(round(height_HPD_upper, 2)," - ", round(height_HPD_lower, 2))), size = 2)+
#   geom_text(aes(label = event), x = -27, y = Inf, hjust = "left", vjust = 1.7, check_overlap = T)+
#   scale_fill_discrete(labels = labels_facet)+
#   scale_color_manual(values = colors, labels = labels)+
#   scale_x_discrete(labels = labels)+
# scale_y_reverse(breaks = seq(from = 0, to = 30, by = 1))+
#   facet_grid(rows = vars(event), scales = "free_y", space = "free_y", labeller = labeller(event = labels_facet))+
#     theme_bw() +
#   theme(legend.position = "none",
#         panel.grid.major.y = element_blank(),
#         strip.background = element_blank(),
#         strip.text = element_blank())+
#   labs(x = "My before present", y ="") +coord_flip()
#   
# 
# 
# ggplot(tree_data_full[which(!is.na(tree_data_full$event)),])+
#   geom_point(aes(x = as.numeric(height), y = as.numeric(as.factor(direction)), color = direction, group = height), size = 2, position = position_dodge(width = 3))+
#   geom_segment(aes(xend = height_0.95_HPD_lower, x = height_0.95_HPD_upper, y = as.numeric(as.factor(direction))+ as.numeric(height), yend = as.numeric(as.factor(direction))+ as.numeric(height), color = direction), size = 1, alpha = 0.8)+
#   # geom_text(aes(x = as.numeric(height), y = direction, label = paste0(round(height_HPD_upper, 2)," - ", round(height_HPD_lower, 2))), size = 2, vjust = -1.5)+
#     # geom_text_repel(aes(x = as.numeric(height), y = as.numeric(as.factor(direction)), label = paste0(round(height_HPD_upper, 2)," - ", round(height_HPD_lower, 2))), size = 2)+
#   geom_text(aes(label = event), x = -27, y = Inf, hjust = "left", vjust = 1.7, check_overlap = T)+
#   # scale_fill_discrete(labels = labels_facet)+
#   scale_color_manual(values = colors, labels = labels)+
#   # scale_y_discrete(labels = labels)+
#   scale_y_continuous(labels = labels)+
# scale_x_reverse(breaks = seq(from = 0, to = 30, by = 1))+
#   facet_grid(rows = vars(event), scales = "free_y", space = "free_y", labeller = labeller(event = labels_facet))+
#     theme_bw() +
#   theme(legend.position = "none",
#         panel.grid.major.y = element_blank(),
#         strip.background = element_blank(),
#         strip.text = element_blank())+
#   labs(x = "My before present", y ="")
# ggsave(filename = paste0(path_to_output, "FIGURE_DEC_Splitting_events_Monodoreae_3.pdf"), units = "cm", width = 30, height = 20)


```

```{r}
data <- tree_data_full[which(!is.na(tree_data_full$event)),]
data <- arrange(data, event, direction, height)
data$y_position
as.numeric(as.factor(data$event))
as.numeric(as.factor(paste0(data$event,"-", data$direction)))

ggplot(tree_data_full[which(!is.na(tree_data_full$event)),])+
  geom_point(aes(x = as.numeric(height), y = as.numeric(as.factor(height)), color = direction), size = 2)+
  # geom_segment(aes(xend = height_0.95_HPD_lower, x = height_0.95_HPD_upper, y = direction, yend = direction, color = direction), size = 1, alpha = 0.8, position = position_nudge(y = 0))+
  # geom_text(aes(x = as.numeric(height), y = direction, label = paste0(round(height_HPD_upper, 2)," - ", round(height_HPD_lower, 2))), size = 2, vjust = -1.5)+
    # geom_text_repel(aes(x = as.numeric(height), y = direction, label = paste0(round(height_HPD_upper, 2)," - ", round(height_HPD_lower, 2))), size = 2)+
  # geom_text(aes(label = event), x = -27, y = Inf, hjust = "left", vjust = 1.7, check_overlap = T)+
  # scale_fill_discrete(labels = labels_facet)+
  scale_color_manual(values = colors, labels = labels)+
  scale_y_discrete(labels = labels)+
scale_x_reverse(breaks = seq(from = 0, to = 30, by = 1))+
    theme_bw() +
  theme(legend.position = "none",
        panel.grid.major.y = element_blank())+
  labs(x = "My before present", y ="")
```



## Extract the vicariance and sympatry splits events ROUND 2
Get the nodes number with vicariances. This is different from above, in order to consier the anagenetic events (range expansion or contraction) along the branches and not at the nodes.  

```{r}
tree_data_events <- tree_data_full[, c("node", "height_0.95_HPD", "height")]
tree_data_events$event <-  NA
tree_data_events$direction <- NA
# vicariance 
centre_east <- c(119, 102, 97, 129, 174)
east_west <- c(147)
centre_west <- c(109, 162, 156)
for (n in centre_east){
  tree_data_events$event[which(tree_data_events$node == n)] <- "vicariance"
  tree_data_events$direction[which(tree_data_events$node == n)] <- "centre_east"
}
for (n in east_west){
  tree_data_events$event[which(tree_data_events$node == n)] <- "vicariance"
  tree_data_events$direction[which(tree_data_events$node == n)] <- "east_west"
}
for (n in centre_west){
  tree_data_events$event[which(tree_data_events$node == n)] <- "vicariance"
  tree_data_events$direction[which(tree_data_events$node == n)] <- "centre_west"
}

# founder event
east_mada <- c(112)
for (n in east_mada ){
  tree_data_events$event[which(tree_data_events$node == n)] <- "founder_event"
  tree_data_events$direction[which(tree_data_events$node == n)] <- "east_mada"
}

library(dplyr)
a = bind_cols(tree_data_events$height_0.95_HPD)
tree_data_events$height_0.95_HPD_lower <- as.numeric(a[1,])
tree_data_events$height_0.95_HPD_upper <- as.numeric(a[2,])

# sympatry (subset) = range contraction
# Here for each event, we need to retrieve the 2 nodes around the corresponding branch

widespread_east_from <- c(111, 105, 131, 169, 146, 136)
widespread_east_to <- c(112, 34, 41, 79, 60, 137)

CE_WCE_centre_from <- c(107, 106, 92, 130, 168, 139, 172, 125)
CE_WCE_centre_to <- c(108, 120, 93, 132, 80, 140, 175, 126)

WC_centre_from <-  c(145)
WC_centre_to <-  c(52)

widespread_west_from <- c(117, 154, 144, 173)
widespread_west_to <- c(118, 170, 50, 85)

for (n in widespread_east_from ){
  tree_data_events$event[which(tree_data_events$node == n)] <- "sympatry_subset"
  tree_data_events$direction[which(tree_data_events$node == n)] <- "widespread_east"
  tree_data_events$height_0.95_HPD_upper[which(tree_data_events$node == n)] <- tree_data_events$height[which(tree_data_events$node == n)]
  tree_data_events$height_0.95_HPD_lower[which(tree_data_events$node == n)]  <- tree_data_events$height[which(tree_data_events$node == widespread_east_to[which(widespread_east_from == n)])]
}
for (n in CE_WCE_centre_from ){
  tree_data_events$event[which(tree_data_events$node == n)] <- "sympatry_subset"
  tree_data_events$direction[which(tree_data_events$node == n)] <- "CE_WCE_centre"
  tree_data_events$height_0.95_HPD_upper[which(tree_data_events$node == n)] <- tree_data_events$height[which(tree_data_events$node == n)]
  tree_data_events$height_0.95_HPD_lower[which(tree_data_events$node == n)]  <- tree_data_events$height[which(tree_data_events$node == CE_WCE_centre_to[which(CE_WCE_centre_from == n)])]
}
for (n in WC_centre_from ){
  tree_data_events$event[which(tree_data_events$node == n)] <- "sympatry_subset"
  tree_data_events$direction[which(tree_data_events$node == n)] <- "WC_centre"
  tree_data_events$height_0.95_HPD_upper[which(tree_data_events$node == n)] <- tree_data_events$height[which(tree_data_events$node == n)]
  tree_data_events$height_0.95_HPD_lower[which(tree_data_events$node == n)]  <- tree_data_events$height[which(tree_data_events$node == WC_centre_to[which(WC_centre_from == n)])]
}
for (n in widespread_west_from ){
  tree_data_events$event[which(tree_data_events$node == n)] <- "sympatry_subset"
  tree_data_events$direction[which(tree_data_events$node == n)] <- "widespread_west"
  tree_data_events$height_0.95_HPD_upper[which(tree_data_events$node == n)] <- tree_data_events$height[which(tree_data_events$node == n)]
  tree_data_events$height_0.95_HPD_lower[which(tree_data_events$node == n)]  <- tree_data_events$height[which(tree_data_events$node == widespread_west_to[which(widespread_west_from == n)])]
}

# range expansion
east_CE_WCE_from <- c(171, 138, 124, 91, 135)
east_CE_WCE_to <- c(172, 139, 125, 92, 136)

centre_WC_from <- c(143, 161, 94, 93, 96, 108)
centre_WC_to <- c(144, 162, 1, 3, 4, 109)

centre_CE_from <-  c(127)
centre_CE_to <-  c(128)

west_WC_from <- c(170, 118)
west_WC_to <- c(81, 25)

for (n in east_CE_WCE_from ){
  tree_data_events$event[which(tree_data_events$node == n)] <- "range_expansion"
  tree_data_events$direction[which(tree_data_events$node == n)] <- "east_CE_WCE"
  tree_data_events$height_0.95_HPD_upper[which(tree_data_events$node == n)] <- tree_data_events$height[which(tree_data_events$node == n)]
  tree_data_events$height_0.95_HPD_lower[which(tree_data_events$node == n)]  <- tree_data_events$height[which(tree_data_events$node == east_CE_WCE_to[which(east_CE_WCE_from == n)])]
}
for (n in centre_WC_from ){
    tree_data_events$event[which(tree_data_events$node == n)] <- "range_expansion"
  tree_data_events$direction[which(tree_data_events$node == n)] <- "centre_WC"
  tree_data_events$height_0.95_HPD_upper[which(tree_data_events$node == n)] <- tree_data_events$height[which(tree_data_events$node == n)]
  tree_data_events$height_0.95_HPD_lower[which(tree_data_events$node == n)]  <- tree_data_events$height[which(tree_data_events$node == centre_WC_to[which(centre_WC_from == n)])]
}
for (n in centre_CE_from ){
    tree_data_events$event[which(tree_data_events$node == n)] <- "range_expansion"
  tree_data_events$direction[which(tree_data_events$node == n)] <- "centre_CE"
  tree_data_events$height_0.95_HPD_upper[which(tree_data_events$node == n)] <- tree_data_events$height[which(tree_data_events$node == n)]
  tree_data_events$height_0.95_HPD_lower[which(tree_data_events$node == n)]  <- tree_data_events$height[which(tree_data_events$node == centre_CE_to[which(centre_CE_from == n)])]
}
for (n in west_WC_from ){
    tree_data_events$event[which(tree_data_events$node == n)] <- "range_expansion"
  tree_data_events$direction[which(tree_data_events$node == n)] <- "west_WC"
  tree_data_events$height_0.95_HPD_upper[which(tree_data_events$node == n)] <- tree_data_events$height[which(tree_data_events$node == n)]
  tree_data_events$height_0.95_HPD_lower[which(tree_data_events$node == n)]  <- tree_data_events$height[which(tree_data_events$node == west_WC_to[which(west_WC_from == n)])]
}

tree_data_events$height_0.95_HPD_lower <- as.numeric(tree_data_events$height_0.95_HPD_lower)
tree_data_events$height_0.95_HPD_upper <- as.numeric(tree_data_events$height_0.95_HPD_upper)
```

## Plot the vicariance and sympatry events
```{r}
library(ggrepel)
seq(from = -0.1, to = 0.1, by = 0.02)

# colors = c("W" = "#e41a1c", "C" = "#377eb8", "E" = "#4daf4a", "M" = "#ffff33", "WC" = "#984ea3", "CE" = "#35978f", "EM" = "#ff7f00", "WCE" = "#a65628") # Color mixing set perso 5
# colors <- c("centre_east" = "#35978f", "east_west" = "#a65628", "centre_west" = "#984ea3", "east_mada" = "#ffff33", "widespread_east" = "#4daf4a", "CE_WCE_centre" = "#377eb8", "WC_centre" = "#377eb8", "widespread_west" = "#e41a1c", "east_CE_WCE" = "#4daf4a", "centre_WC" = "#377eb8", "centre_CE" = "#377eb8", "west_WC" = "#e41a1c")


colors = c("W" = "#e41a1c", "C" = "#008cff", "E" = "#1da819", "M" = "#ffff33", "WC" = "#984ea3", "CE" = "#14c9a9", "EM" = "#ff7f00", "WCE" = "#a65628") # Color mixing set perso 6 (= clearer set5)
demoplot(colors, "pie")
colors <- c("centre_east" = "#14c9a9", "east_west" = "#a65628", "centre_west" = "#984ea3", "east_mada" = "#ffff33", "widespread_east" = "#1da819", "CE_WCE_centre" = "#008cff", "WC_centre" = "#008cff", "widespread_west" = "#e41a1c", "east_CE_WCE" = "#1da819", "centre_WC" = "#008cff", "centre_CE" = "#008cff", "west_WC" = "#e41a1c")
demoplot(colors, "pie")

labels <- c("centre_east" = "Centre-East", "east_west" = "East-West", "centre_west" = "Centre-West", "east_mada" = "East to Madagascar", "widespread_east" = "Widespread to East", "CE_WCE_centre" = "Centre-East or West-Centre-East to Centre", "WC_centre" = "West-Centre to Centre", "widespread_west" = "Widespread to West", "east_CE_WCE" = "East to Widespread", "centre_WC" = "Centre to West-Centre", "centre_CE" = "Centre to Centre-East", "west_WC" = "West to West-Centre")

tree_data_events$event[which(tree_data_events$event =="vicariance")] <- "Vicariance"
tree_data_events$event[which(tree_data_events$event =="founder_event")] <- "Founder event"
tree_data_events$event[which(tree_data_events$event =="range_expansion")] <- "Range expansion (dispersion)"
tree_data_events$event[which(tree_data_events$event =="sympatry_subset")] <- "Range contraction (sympatry subset)"

labels_facet = c("vicariance" = "Vicariance", "founder_event" = "Founder event", "sympatry_subset" = "Range contraction (sympatry subset)", "range_expansion" = "Range expansion")


data <- tree_data_events[which(!is.na(tree_data_events$event)),]
data <- arrange(data, event, desc(direction), (as.numeric(height)))
data$nudge_y <- NA
data$levels <-  paste0(data$event, "_", data$direction)
table_lev <-  table(data$levels)


for (lev in unique(data$levels)){
  by <-  0.15
  length <-  length(which(data$levels == lev))
  if (length < 9){
      data$nudge_y[which(data$levels == lev)] <-  round(seq(from = -(by*length/2)+by/2, length.out = length, by = by), 2)    
  } else {
     data$nudge_y[which(data$levels == lev)] <-  c(round(seq(from = -(by*(length-1)/2)+by/2, length.out = length-1, by = by), 2), 0)   
  }
}

g <- ggplot(data)+
  geom_point(aes(x = as.numeric(height), y = direction, color = direction), size = 2.5, position = position_nudge(y = data$nudge_y))+
  geom_segment(aes(xend = height_0.95_HPD_lower, x = height_0.95_HPD_upper, y = direction, yend = direction, color = direction), size = 1.7, alpha = 1, position = position_nudge(y = data$nudge_y))+
  geom_text(aes(x = as.numeric(height_0.95_HPD_lower), y = direction, label = paste0(round(height_0.95_HPD_upper, 2)," - ", round(height_0.95_HPD_lower, 2))), size = 2, position = position_nudge(y = data$nudge_y, x = 0.1), hjust = "left")+
  geom_text(aes(label = event), x = -25, y = Inf, hjust = "left", vjust = 1.7, check_overlap = T)+
  scale_fill_discrete(labels = labels_facet)+
  scale_color_manual(values = colors, labels = labels)+
  scale_y_discrete(labels = labels)+
scale_x_reverse(breaks = seq(from = 0, to = 27, by = 1), limits = c(25,-1), minor_breaks = seq(from = 0.5, to = 26.5, by = 1))+
  facet_grid(rows = vars(event), scales = "free_y", space = "free_y", labeller = labeller(event = labels_facet))+
    theme_bw() +
  theme(legend.position = "none",
        panel.grid.major.y = element_blank(),
        strip.background = element_blank(),
        strip.text = element_blank())+
  labs(x = "My before present", y ="")
g
ggsave(filename = paste0("FIGURE_DEC_Splitting_events_Monodoreae_3_ROUND2_test.pdf"), units = "cm", width = 30, height = 20)
```

```{r}
svg(file = paste0("FIGURE_DEC_Splitting_events_Monodoreae_3_ROUND2.svg"), width = 15, height = 10 )
g
dev.off()
```

### with geological timescale
```{r}
library(deeptime)
GTS <- force(epochs)
lmio <-  c("Late Miocene", 11.6300, 5.3330, "L.Mio", "#FFFF66")
mmio <-  c("Middle Miocene", 15.9700, 11.6300, "M.Mio", "#FFFF4D")
emio <-  c("Early Miocene", 23.0300, 15.9700, "E.Mio", "#FFFF33")
GTS_perso <- rbind(GTS[c(1:3),], lmio, mmio, emio, GTS[5,])
GTS_perso$max_age <- as.numeric(GTS_perso$max_age)
GTS_perso$min_age <- as.numeric(GTS_perso$min_age)

g2 = g+ coord_geo(neg = F, pos = "b", dat = GTS_perso, abbrv = F, height = unit(1, "line"), size = 3, bord = c(), skip = c("Holocene"), expand = T, center_end_labels = T)
# ggsave(filename = paste0("FIGURE_DEC_Splitting_events_Monodoreae_3_ROUND2_test_GTS.pdf"), units = "cm", width = 30, height = 20)

pdf(file = paste0("FIGURE_DEC_Splitting_events_Monodoreae_3_ROUND2_GTS_ok_for_publi.pdf"), width = 11.8 , height = 7.9)
g2
dev.off()
```


#
#
#
#
#
#
#
#
#
#
#


# DIVALIKE and DIVALIKE+J analysis

Run DIVALIKE.
```{r}
BioGeoBEARS_run_object = define_BioGeoBEARS_run()
BioGeoBEARS_run_object$trfn = path_to_treefile
BioGeoBEARS_run_object$geogfn = path_to_geotf
BioGeoBEARS_run_object$max_range_size = max_range_size
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.

# INPUT the NEW states list into the BioGeoBEARS_run_object
BioGeoBEARS_run_object$states_list = states_list_0based_NEW

# Speed options and multicore processing if desired
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()
BioGeoBEARS_run_object$num_cores_to_use = 1
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale

# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!
# (It also runs some checks on these inputs for certain errors.)
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)

# Good default settings to get ancestral states
BioGeoBEARS_run_object$return_condlikes_table = TRUE
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run
# Set up DIVALIKE model
# Remove subset-sympatry
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0

BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "2-j"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/2"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "ysv*1/2"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "ysv*1/2"

# Allow classic, widespread vicariance; all events equiprobable
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","type"] = "fixed"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","init"] = 0.5
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","est"] = 0.5

# No jump dispersal/founder-event speciation
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = 0.01
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = 0.01

check_BioGeoBEARS_run(BioGeoBEARS_run_object)
runslow = F
resfn = paste0(data_prefix, "_DIVALIKE_M0_unconstrained_v1.Rdata")
if (runslow)
    {
    res = bears_optim_run(BioGeoBEARS_run_object)
    res    

    save(res, file=resfn)
    resDIVALIKE = res
    } else {
    # Loads to "res"
    load(resfn)
    resDIVALIKE = res
    }
```

Run DIVALIKE+J.
```{r}
BioGeoBEARS_run_object = define_BioGeoBEARS_run()
BioGeoBEARS_run_object$trfn = path_to_treefile
BioGeoBEARS_run_object$geogfn = path_to_geotf
BioGeoBEARS_run_object$max_range_size = max_range_size
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.
# Speed options and multicore processing if desired
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()
BioGeoBEARS_run_object$num_cores_to_use = 1
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale

# INPUT the NEW states list into the BioGeoBEARS_run_object
BioGeoBEARS_run_object$states_list = states_list_0based_NEW

# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!
# (It also runs some checks on these inputs for certain errors.)
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)

# Good default settings to get ancestral states
BioGeoBEARS_run_object$return_condlikes_table = TRUE
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run

# Set up DIVALIKE+J model
# Get the ML parameter values from the 2-parameter nested model
# (this will ensure that the 3-parameter model always does at least as good)
dstart = resDIVALIKE$outputs@params_table["d","est"]
estart = resDIVALIKE$outputs@params_table["e","est"]
jstart = 0.0001

# Input starting values for d, e
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart

# Remove subset-sympatry
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0

BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "2-j"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/2"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "ysv*1/2"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "ysv*1/2"

# Allow classic, widespread vicariance; all events equiprobable
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","type"] = "fixed"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","init"] = 0.5
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01v","est"] = 0.5

# Add jump dispersal/founder-event speciation
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart

# Under DIVALIKE+J, the max of "j" should be 2, not 3 (as is default in DEC+J)
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","min"] = 0.00001
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 1.99999

check_BioGeoBEARS_run(BioGeoBEARS_run_object)

resfn = paste0(data_prefix, "_DIVALIKE+J_M0_unconstrained_v1.Rdata")
runslow = F
if (runslow)
    {

    res = bears_optim_run(BioGeoBEARS_run_object)
    res    

    save(res, file=resfn)

    resDIVALIKEj = res
    } else {
    # Loads to "res"
    load(resfn)
    resDIVALIKEj = res
    }
```

## Plot ancestral states - DIVALIKE
```{r}

analysis_titletxt = paste0("BioGeoBEARS DIVALIKE on ", data_text," M0_unconstrained")

# Setup
results_object = resDIVALIKE
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))

# States
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tree, tipranges=tipranges)

# Pie chart
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tree, tipranges=tipranges)

```

## Plot ancestral states - DIVALIKE+J
```{r}
analysis_titletxt = paste0("BioGeoBEARS DIVALIKE+J on ", data_text," M0_unconstrained")

# Setup
results_object = resDIVALIKEj
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))

# States
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tree, tipranges=tipranges)

# Pie chart
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tree, tipranges=tipranges)
```

# BAYAREALIKE and BAYAREALIKE+J analysis

Run BAYAREALIKE.
```{r}
BioGeoBEARS_run_object = define_BioGeoBEARS_run()
BioGeoBEARS_run_object$trfn = path_to_treefile
BioGeoBEARS_run_object$geogfn = path_to_geotf
BioGeoBEARS_run_object$max_range_size = max_range_size
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.

# INPUT the NEW states list into the BioGeoBEARS_run_object
BioGeoBEARS_run_object$states_list = states_list_0based_NEW

# Speed options and multicore processing if desired
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)
BioGeoBEARS_run_object$use_optimx = "GenSA"    # if FALSE, use optim() instead of optimx()
BioGeoBEARS_run_object$num_cores_to_use = 1
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale

# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!
# (It also runs some checks on these inputs for certain errors.)
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)

# Good default settings to get ancestral states
BioGeoBEARS_run_object$return_condlikes_table = TRUE
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run

# Set up BAYAREALIKE model
# No subset sympatry
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0

# No vicariance
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "fixed"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","init"] = 0.0
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","est"] = 0.0

# No jump dispersal/founder-event speciation
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = 0.01
# BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = 0.01

# Adjust linkage between parameters
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "1-j"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/1"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "1-j"

# Only sympatric/range-copying (y) events allowed, and with 
# exact copying (both descendants always the same size as the ancestor)
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","type"] = "fixed"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","init"] = 0.9999
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","est"] = 0.9999

# Check the inputs
check_BioGeoBEARS_run(BioGeoBEARS_run_object)

runslow = F
resfn = paste0(data_prefix, "_BAYAREALIKE_M0_unconstrained_v1.Rdata")
if (runslow)
    {
    res = bears_optim_run(BioGeoBEARS_run_object)
    res    

    save(res, file=resfn)
    resBAYAREALIKE = res
    } else {
    # Loads to "res"
    load(resfn)
    resBAYAREALIKE = res
    }
```

Run BAYAREALIKE+J.
```{r}
BioGeoBEARS_run_object = define_BioGeoBEARS_run()
BioGeoBEARS_run_object$trfn = path_to_treefile
BioGeoBEARS_run_object$geogfn = path_to_geotf
BioGeoBEARS_run_object$max_range_size = max_range_size
BioGeoBEARS_run_object$min_branchlength = 0.000001    # Min to treat tip as a direct ancestor (no speciation event)
BioGeoBEARS_run_object$include_null_range = TRUE    # set to FALSE for e.g. DEC* model, DEC*+J, etc.

# INPUT the NEW states list into the BioGeoBEARS_run_object
BioGeoBEARS_run_object$states_list = states_list_0based_NEW

# Speed options and multicore processing if desired
BioGeoBEARS_run_object$on_NaN_error = -1e50    # returns very low lnL if parameters produce NaN error (underflow check)
BioGeoBEARS_run_object$speedup = TRUE          # shorcuts to speed ML search; use FALSE if worried (e.g. >3 params)
BioGeoBEARS_run_object$use_optimx = "GenSA"
BioGeoBEARS_run_object$num_cores_to_use = 1
BioGeoBEARS_run_object$force_sparse = FALSE    # force_sparse=TRUE causes pathology & isn't much faster at this scale

# This function loads the dispersal multiplier matrix etc. from the text files into the model object. Required for these to work!
# (It also runs some checks on these inputs for certain errors.)
BioGeoBEARS_run_object = readfiles_BioGeoBEARS_run(BioGeoBEARS_run_object)

# Good default settings to get ancestral states
BioGeoBEARS_run_object$return_condlikes_table = TRUE
BioGeoBEARS_run_object$calc_TTL_loglike_from_condlikes_table = TRUE
BioGeoBEARS_run_object$calc_ancprobs = TRUE    # get ancestral states from optim run

# Set up BAYAREALIKE+J model
# Get the ML parameter values from the 2-parameter nested model
# (this will ensure that the 3-parameter model always does at least as good)
dstart = resBAYAREALIKE$outputs@params_table["d","est"]
estart = resBAYAREALIKE$outputs@params_table["e","est"]
jstart = 0.0001

# Input starting values for d, e
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","init"] = dstart
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["d","est"] = dstart
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","init"] = estart
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["e","est"] = estart

# No subset sympatry
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","type"] = "fixed"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","init"] = 0.0
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["s","est"] = 0.0

# No vicariance
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","type"] = "fixed"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","init"] = 0.0
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["v","est"] = 0.0

# *DO* allow jump dispersal/founder-event speciation (set the starting value close to 0)
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","type"] = "free"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","init"] = jstart
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","est"] = jstart

# Under BAYAREALIKE+J, the max of "j" should be 1, not 3 (as is default in DEC+J) or 2 (as in DIVALIKE+J)
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["j","max"] = 0.99999

# Adjust linkage between parameters
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ysv","type"] = "1-j"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["ys","type"] = "ysv*1/1"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["y","type"] = "1-j"

# Only sympatric/range-copying (y) events allowed, and with 
# exact copying (both descendants always the same size as the ancestor)
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","type"] = "fixed"
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","init"] = 0.9999
BioGeoBEARS_run_object$BioGeoBEARS_model_object@params_table["mx01y","est"] = 0.9999

check_BioGeoBEARS_run(BioGeoBEARS_run_object)

resfn = paste0(data_prefix, "_BAYAREALIKE+J_M0_unconstrained_v1.Rdata")
runslow = F
if (runslow)
    {
    res = bears_optim_run(BioGeoBEARS_run_object)
    res    

    save(res, file=resfn)

    resBAYAREALIKEj = res
    } else {
    # Loads to "res"
    load(resfn)
    resBAYAREALIKEj = res
    }
```

## Plot ancestral states - BAYAREALIKE
```{r}
analysis_titletxt =paste0("BioGeoBEARS BAYAREALIKE on ", data_text, " M0_unconstrained")

# Setup
results_object = resBAYAREALIKE
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))

# States
res2 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tree, tipranges=tipranges)

# Pie chart
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tree, tipranges=tipranges)
```

## Plot ancestral states - BAYAREALIKE+J
```{r}
analysis_titletxt =paste0("BioGeoBEARS BAYAREALIKE+J on ", data_text, " M0_unconstrained")

# Setup
results_object = resBAYAREALIKEj
scriptdir = np(system.file("extdata/a_scripts", package="BioGeoBEARS"))

# States
res1 = plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="text", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tree, tipranges=tipranges)

# Pie chart
plot_BioGeoBEARS_results(results_object, analysis_titletxt, addl_params=list("j"), plotwhat="pie", label.offset=0.45, tipcex=0.7, statecex=0.7, splitcex=0.6, titlecex=0.8, plotsplits=TRUE, cornercoords_loc=scriptdir, include_null_range=TRUE, tr=tree, tipranges=tipranges)

```

# Calculate summary statistics to compare DEC, DEC+J, DIVALIKE, DIVALIKE+J, BAYAREALIKE, BAYAREALIKE+J

```{r}
# Set up empty tables to hold the statistical results
restable = NULL
teststable = NULL

#######################################################
# Statistics -- DEC vs. DEC+J
#######################################################
# We have to extract the log-likelihood differently, depending on the 
# version of optim/optimx
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resDEC)
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resDECj)
numparams1 = 3
numparams2 = 2
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)
stats

# DEC, null model for Likelihood Ratio Test (LRT)
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resDEC, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)
# DEC+J, alternative model for Likelihood Ratio Test (LRT)
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resDECj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)

# The null hypothesis for a Likelihood Ratio Test (LRT) is that two models
# confer the same likelihood on the data. See: Brian O'Meara's webpage:
# http://www.brianomeara.info/tutorials/aic
# ...for an intro to LRT, AIC, and AICc

rbind(res2, res1)
tmp_tests = conditional_format_table(stats)

restable = rbind(restable, res2, res1)
teststable = rbind(teststable, tmp_tests)

#######################################################
# Statistics -- DIVALIKE vs. DIVALIKE+J
#######################################################
# We have to extract the log-likelihood differently, depending on the 
# version of optim/optimx
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resDIVALIKE)
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resDIVALIKEj)

numparams1 = 3
numparams2 = 2
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)
stats

# DIVALIKE, null model for Likelihood Ratio Test (LRT)
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resDIVALIKE, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)
# DIVALIKE+J, alternative model for Likelihood Ratio Test (LRT)
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resDIVALIKEj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)

rbind(res2, res1)
conditional_format_table(stats)

tmp_tests = conditional_format_table(stats)

restable = rbind(restable, res2, res1)
teststable = rbind(teststable, tmp_tests)

#######################################################
# Statistics -- BAYAREALIKE vs. BAYAREALIKE+J
#######################################################
# We have to extract the log-likelihood differently, depending on the 
# version of optim/optimx
LnL_2 = get_LnL_from_BioGeoBEARS_results_object(resBAYAREALIKE)
LnL_1 = get_LnL_from_BioGeoBEARS_results_object(resBAYAREALIKEj)

numparams1 = 3
numparams2 = 2
stats = AICstats_2models(LnL_1, LnL_2, numparams1, numparams2)
stats

# BAYAREALIKE, null model for Likelihood Ratio Test (LRT)
res2 = extract_params_from_BioGeoBEARS_results_object(results_object=resBAYAREALIKE, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)
# BAYAREALIKE+J, alternative model for Likelihood Ratio Test (LRT)
res1 = extract_params_from_BioGeoBEARS_results_object(results_object=resBAYAREALIKEj, returnwhat="table", addl_params=c("j"), paramsstr_digits=4)

rbind(res2, res1)
conditional_format_table(stats)

tmp_tests = conditional_format_table(stats)

restable = rbind(restable, res2, res1)
teststable = rbind(teststable, tmp_tests)

#########################################################################
# ASSEMBLE RESULTS TABLES: DEC, DEC+J, DIVALIKE, DIVALIKE+J, BAYAREALIKE, BAYAREALIKE+J
#########################################################################
teststable$alt = c("DEC+J", "DIVALIKE+J", "BAYAREALIKE+J")
teststable$null = c("DEC", "DIVALIKE", "BAYAREALIKE")
row.names(restable) = c("DEC", "DEC+J", "DIVALIKE", "DIVALIKE+J", "BAYAREALIKE", "BAYAREALIKE+J")
restable = put_jcol_after_ecol(restable)
restable

# Look at the results!!
restable
teststable


# Loads to "restable"
save(restable, file="restable_v1.Rdata")
load(file="restable_v1.Rdata")

# Loads to "teststable"
save(teststable, file="teststable_v1.Rdata")
load(file="teststable_v1.Rdata")

# Also save to text files
write.table(restable, file="restable_v1.txt", quote=FALSE, sep="\t")
write.table(unlist_df(teststable), file="teststable_v1.txt", quote=FALSE, sep="\t")

#######################################################
# Model weights of all six models
#######################################################
restable2 = restable

# With AICs:
AICtable = calc_AIC_column(LnL_vals=restable$LnL, nparam_vals=restable$numparams)
restable = cbind(restable, AICtable)
restable_AIC_rellike = AkaikeWeights_on_summary_table(restable=restable, colname_to_use="AIC")
restable_AIC_rellike = put_jcol_after_ecol(restable_AIC_rellike)
restable_AIC_rellike

# With AICcs -- factors in sample size
samplesize = length(tree$tip.label)
AICtable = calc_AICc_column(LnL_vals=restable$LnL, nparam_vals=restable$numparams, samplesize=samplesize)
restable2 = cbind(restable2, AICtable)
restable_AICc_rellike = AkaikeWeights_on_summary_table(restable=restable2, colname_to_use="AICc")
restable_AICc_rellike = put_jcol_after_ecol(restable_AICc_rellike)
restable_AICc_rellike

# Also save to text files
write.table(restable_AIC_rellike, file="restable_AIC_rellike_v1.txt", quote=FALSE, sep="\t")
write.table(restable_AICc_rellike, file="restable_AICc_rellike_v1.txt", quote=FALSE, sep="\t")

# Save with nice conditional formatting
write.table(conditional_format_table(restable_AIC_rellike), file="restable_AIC_rellike_formatted_v1.txt", quote=FALSE, sep="\t")
write.table(conditional_format_table(restable_AICc_rellike), file="restable_AICc_rellike_formatted_v1.txt", quote=FALSE, sep="\t")

```

